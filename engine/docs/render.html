<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Engine v2 Render Glossary</title>
  <link rel="stylesheet" href="glossary.css">
  <style>
    :root {
      --accent: #38bdf8;
      --fg-muted: #94a3b8;
      --fg: #e2e8f0;
      --border: #334155;
      --bg-tertiary: #1a1f2e;
    }

    .top-nav {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 60px;
      background: linear-gradient(to bottom, #1e293b, #1a1f2e);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      padding: 0 24px;
      gap: 32px;
      z-index: 1000;
    }

    .top-nav h1 {
      margin: 0;
      font-size: 18px;
      font-weight: 700;
      color: var(--fg);
      letter-spacing: -0.5px;
    }

    .top-nav nav {
      display: flex;
      gap: 8px;
      flex: 1;
    }

    .top-nav .nav-link {
      padding: 8px 16px;
      background: transparent;
      border: none;
      color: var(--fg-muted);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 0.2s;
      text-decoration: none;
    }

    .top-nav .nav-link:hover {
      color: var(--fg);
      background: rgba(56, 189, 248, 0.05);
    }

    .top-nav .nav-link.active {
      color: var(--accent);
      border-bottom-color: var(--accent);
    }

    .page {
      margin-top: 60px !important;
    }

    /* Override glossary.css nav to not conflict */
    .page > nav {
      position: sticky;
      top: 70px;
      z-index: 100;
    }
  </style>
</head>
<body>
  <!-- Top Navigation -->
  <div class="top-nav">
    <h1>Engine v2 – Documentation</h1>
    <nav>
      <a href="../../" class="nav-link">← Back to Hub</a>
      <a href="index.html" class="nav-link">Overview</a>
      <a href="core.html" class="nav-link">Core</a>
      <a href="ecs.html" class="nav-link">ECS</a>
      <a href="render.html" class="nav-link active">Render</a>
      <a href="sim.html" class="nav-link">Sim</a>
    </nav>
  </div>

  <div class="page">
    <header class="site-header" id="top">
      <h1>Engine v2 – render</h1>
      <p class="summary">GPU-driven rendering pipeline: meshes, materials, passes, Forward+/clustered lighting, shadows, and post-processing.</p>
      <p class="path">Path: <code>engine/render/*</code></p>
    </header>

    <nav aria-label="Render glossary table of contents">
      <h2>Contents</h2>
      <p class="note">Flat list of core rendering concepts.</p>
      <ul>
        <li><a href="#term-mesh">Mesh</a></li>
        <li><a href="#term-material">Material</a></li>
        <li><a href="#term-material-descriptor">Material descriptor</a></li>
        <li><a href="#term-pbr-material">PBR material</a></li>
        <li><a href="#term-render-pass">Render pass</a></li>
        <li><a href="#term-depth-prepass">Depth prepass</a></li>
        <li><a href="#term-forward-plus">Forward+ lighting</a></li>
        <li><a href="#term-light-buffer">Light buffer</a></li>
        <li><a href="#term-shadow-map">Shadow map</a></li>
        <li><a href="#term-postfx-pass">Post-processing pass</a></li>
        <li><a href="#term-hdr-pipeline">HDR pipeline</a></li>
      </ul>
    </nav>

    <main>
      <h2 class="section-title">Rendering pipeline concepts</h2>
      <p class="section-intro">The render layer builds on core/framegraph to draw ECS-renderable entities with PBR lighting and postfx.</p>
      <div class="term-list">
        <article class="term" id="term-mesh">
          <h3>Mesh</h3>
          <p><strong class="label">Definition</strong> CPU representation of geometry that references GPU vertex/index buffers, material id, and bounds.</p>
          <div class="example">
            <strong class="label">Example</strong>
            <pre><code>const mesh = new Mesh({
  vertexBuffer: vb,
  indexBuffer: ib,
  indexCount: 36,
  materialId: 'cube_pbr',
});
</code></pre>
          </div>
          <p class="related"><strong class="label">Related</strong> <a href="#term-material">Material</a></p>
          <p class="back-top"><a href="#top">Back to top</a></p>
        </article>

        <article class="term" id="term-material">
          <h3>Material</h3>
          <p><strong class="label">Definition</strong> Logical description of how a surface is shaded: references shaders, textures, samplers, and uniform parameters.</p>
          <div class="example">
            <strong class="label">Example</strong>
            <pre><code>const mat = materialSystem.create({
  id: 'cube_pbr',
  shaderId: 'pbr',
  textures: { baseColor: 'albedo.png' },
});
</code></pre>
          </div>
          <p class="related"><strong class="label">Related</strong> <a href="#term-material-descriptor">Material descriptor</a>, <a href="#term-pbr-material">PBR material</a></p>
          <p class="back-top"><a href="#top">Back to top</a></p>
        </article>

        <article class="term" id="term-material-descriptor">
          <h3>Material descriptor</h3>
          <p><strong class="label">Definition</strong> Data object describing the parameters, textures, and sampler bindings for a material, used to build bind group layouts.</p>
          <div class="example">
            <strong class="label">Example</strong>
            <pre><code>const desc = {
  params: ['baseColor', 'metallic', 'roughness'],
  textures: ['baseColorTex', 'normalTex'],
};
</code></pre>
          </div>
          <p class="related"><strong class="label">Related</strong> <a href="#term-material">Material</a>, <a href="#term-hdr-pipeline">HDR pipeline</a></p>
          <p class="back-top"><a href="#top">Back to top</a></p>
        </article>

        <article class="term" id="term-pbr-material">
          <h3>PBR material</h3>
          <p><strong class="label">Definition</strong> Physically based shading material using baseColor, metalness, roughness, normal, and environment lighting parameters.</p>
          <div class="example">
            <strong class="label">Example</strong>
            <pre><code>const sphereMat = materialSystem.create({
  id: 'test_sphere',
  shaderId: 'pbr',
  params: { roughness: 0.3, metallic: 1.0 },
});
</code></pre>
          </div>
          <p class="related"><strong class="label">Related</strong> <a href="#term-light-buffer">Light buffer</a>, <a href="#term-shadow-map">Shadow map</a></p>
          <p class="back-top"><a href="#top">Back to top</a></p>
        </article>

        <article class="term" id="term-render-pass">
          <h3>Render pass</h3>
          <p><strong class="label">Definition</strong> Framegraph node that writes to one or more color/depth attachments, issuing draw calls for a subset of the scene.</p>
          <div class="example">
            <strong class="label">Example</strong>
            <pre><code>fg.addRenderPass('geometry', (pass) =&gt; {
  pass.write(colorTex);
  pass.write(depthTex);
  pass.execute((encoder, views) =&gt; {
    // draw visible meshes here
  });
});
</code></pre>
          </div>
          <p class="related"><strong class="label">Related</strong> <a href="#term-depth-prepass">Depth prepass</a>, <a href="#term-postfx-pass">Post-processing pass</a></p>
          <p class="back-top"><a href="#top">Back to top</a></p>
        </article>

        <article class="term" id="term-depth-prepass">
          <h3>Depth prepass</h3>
          <p><strong class="label">Definition</strong> Pass that fills a depth buffer before main shading, improving overdraw performance and enabling effects like SSAO.</p>
          <div class="example">
            <strong class="label">Example</strong>
            <pre><code>fg.addRenderPass('depth-prepass', (pass) =&gt; {
  pass.write(depthTex, { loadOp: 'clear' });
});
</code></pre>
          </div>
          <p class="related"><strong class="label">Related</strong> <a href="#term-forward-plus">Forward+ lighting</a>, <a href="#term-shadow-map">Shadow map</a></p>
          <p class="back-top"><a href="#top">Back to top</a></p>
        </article>

        <article class="term" id="term-forward-plus">
          <h3>Forward+ lighting</h3>
          <p><strong class="label">Definition</strong> Lighting technique where a compute pass builds per-cluster light lists, then a forward pass shades using those lists.</p>
          <div class="example">
            <strong class="label">Example</strong>
            <pre><code>// Pseudocode
fg.addComputePass('build-light-lists', ...);
fg.addRenderPass('forward-plus', ...);
</code></pre>
          </div>
          <p class="related"><strong class="label">Related</strong> <a href="#term-light-buffer">Light buffer</a>, <a href="#term-hdr-pipeline">HDR pipeline</a></p>
          <p class="back-top"><a href="#top">Back to top</a></p>
        </article>

        <article class="term" id="term-light-buffer">
          <h3>Light buffer</h3>
          <p><strong class="label">Definition</strong> Structured/storage buffer storing per-light data used by clustered/Forward+ passes and PBR shaders.</p>
          <div class="example">
            <strong class="label">Example</strong>
            <pre><code>const lightBuffer = GpuBuffer.createStorage(
  device,
  lightArray,
  'lights-ssbo',
);
</code></pre>
          </div>
          <p class="related"><strong class="label">Related</strong> <a href="#term-forward-plus">Forward+ lighting</a></p>
          <p class="back-top"><a href="#top">Back to top</a></p>
        </article>

        <article class="term" id="term-shadow-map">
          <h3>Shadow map</h3>
          <p><strong class="label">Definition</strong> Depth-only texture rendered from the lights point of view, sampled in the lighting pass for basic shadowing.</p>
          <div class="example">
            <strong class="label">Example</strong>
            <pre><code>// Depth-only render pass for directional light
fg.addRenderPass('shadow-map', (pass) =&gt; {
  pass.write(shadowDepthTex, { loadOp: 'clear' });
});
</code></pre>
          </div>
          <p class="related"><strong class="label">Related</strong> <a href="#term-depth-prepass">Depth prepass</a>, <a href="#term-pbr-material">PBR material</a></p>
          <p class="back-top"><a href="#top">Back to top</a></p>
        </article>

        <article class="term" id="term-postfx-pass">
          <h3>Post-processing pass</h3>
          <p><strong class="label">Definition</strong> Pass that takes the main color buffer as input and applies effects like tonemapping, bloom, vignette, or debug overlays.</p>
          <div class="example">
            <strong class="label">Example</strong>
            <pre><code>fg.addRenderPass('postfx', (pass) =&gt; {
  pass.read(colorTex);
  pass.write(ldrColorTex);
});
</code></pre>
          </div>
          <p class="related"><strong class="label">Related</strong> <a href="#term-hdr-pipeline">HDR pipeline</a></p>
          <p class="back-top"><a href="#top">Back to top</a></p>
        </article>

        <article class="term" id="term-hdr-pipeline">
          <h3>HDR pipeline</h3>
          <p><strong class="label">Definition</strong> Rendering path that keeps lighting in a high-dynamic-range color buffer, then tonemaps to display format in post-processing.</p>
          <div class="example">
            <strong class="label">Example</strong>
            <pre><code>// Render to HDR, then tonemap to 8-bit surface
const hdrTex = fg.createTexture({ format: 'rgba16float' });
const ldrTex = fg.createTexture({ format: 'bgra8unorm' });
</code></pre>
          </div>
          <p class="related"><strong class="label">Related</strong> <a href="#term-postfx-pass">Post-processing pass</a>, <a href="#term-material">Material</a></p>
          <p class="back-top"><a href="#top">Back to top</a></p>
        </article>
      </div>
    </main>
  </div>
</body>
</html>
