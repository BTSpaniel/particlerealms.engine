<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Engine v2 Core Glossary</title>
  <link rel="stylesheet" href="glossary.css">
  <style>
    :root {
      --accent: #38bdf8;
      --fg-muted: #94a3b8;
      --fg: #e2e8f0;
      --border: #334155;
      --bg-tertiary: #1a1f2e;
    }

    .top-nav {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 60px;
      background: linear-gradient(to bottom, #1e293b, #1a1f2e);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      padding: 0 24px;
      gap: 32px;
      z-index: 1000;
    }

    .top-nav h1 {
      margin: 0;
      font-size: 18px;
      font-weight: 700;
      color: var(--fg);
      letter-spacing: -0.5px;
    }

    .top-nav nav {
      display: flex;
      gap: 8px;
      flex: 1;
    }

    .top-nav .nav-link {
      padding: 8px 16px;
      background: transparent;
      border: none;
      color: var(--fg-muted);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 0.2s;
      text-decoration: none;
    }

    .top-nav .nav-link:hover {
      color: var(--fg);
      background: rgba(56, 189, 248, 0.05);
    }

    .top-nav .nav-link.active {
      color: var(--accent);
      border-bottom-color: var(--accent);
    }

    .page {
      margin-top: 60px !important;
    }

    /* Override glossary.css nav to not conflict */
    .page > nav {
      position: sticky;
      top: 70px;
      z-index: 100;
    }
  </style>
</head>
<body>
  <!-- Top Navigation -->
  <div class="top-nav">
    <h1>Engine v2 – Documentation</h1>
    <nav>
      <a href="../../" class="nav-link">← Back to Hub</a>
      <a href="index.html" class="nav-link">Overview</a>
      <a href="core.html" class="nav-link active">Core</a>
      <a href="ecs.html" class="nav-link">ECS</a>
      <a href="render.html" class="nav-link">Render</a>
      <a href="sim.html" class="nav-link">Sim</a>
    </nav>
  </div>

  <div class="page">
    <header class="site-header" id="top">
      <h1>Engine v2 – core</h1>
      <p class="summary">Core runtime, WebGPU device/texture/buffer helpers, framegraph, platform loop, and event bus.</p>
      <p class="path">Path: <code>engine/core/*</code></p>
    </header>

    <nav aria-label="Core glossary table of contents">
      <h2>Contents</h2>
      <p class="note">Flat list of core terms. Click to jump within this page.</p>
      <ul>
        <li><a href="#term-webgpu">WebGPU</a></li>
        <li><a href="#term-wgsl">WGSL</a></li>
        <li><a href="#term-gpudevicemanager">GPUDeviceManager</a></li>
        <li><a href="#term-gpubuffer">GpuBuffer</a></li>
        <li><a href="#term-gputexture">GpuTexture</a></li>
        <li><a href="#term-gpusampler">GpuSampler</a></li>
        <li><a href="#term-framegraph">Framegraph</a></li>
        <li><a href="#term-frame-loop">Frame loop</a></li>
        <li><a href="#term-platform-canvas">Platform canvas binding</a></li>
        <li><a href="#term-event-bus">Event bus</a></li>
      </ul>
    </nav>

    <main>
      <h2 class="section-title">Core runtime &amp; GPU abstractions</h2>
      <p class="section-intro">These terms cover the low-level building blocks that everything else in Engine v2 sits on.</p>
      <div class="term-list">
        <article class="term" id="term-webgpu">
          <h3>WebGPU</h3>
          <p><strong class="label">Definition</strong> Browser GPU API used for all rendering and compute in Engine v2. Replaces WebGL/Three.js and has no software fallback.</p>
          <div class="example">
            <strong class="label">Example</strong>
            <pre><code>const adapter = await navigator.gpu.requestAdapter();
if (!adapter) throw new Error('WebGPU not available');
const device = await adapter.requestDevice();
console.log(device.limits.maxTextureDimension2D);
</code></pre>
          </div>
          <p class="related"><strong class="label">Related</strong> <a href="#term-gpudevicemanager">GPUDeviceManager</a>, <a href="#term-wgsl">WGSL</a></p>
          <p class="back-top"><a href="#top">Back to top</a></p>
        </article>

        <article class="term" id="term-wgsl">
          <h3>WGSL</h3>
          <p><strong class="label">Definition</strong> WebGPU Shading Language. All Engine v2 vertex, fragment, and compute shaders live as WGSL modules in <code>engine/render/shaders/*</code>.</p>
          <div class="example">
            <strong class="label">Example</strong>
            <pre><code>// Minimal WGSL vertex shader
@vertex
fn vs_main(@location(0) position : vec3f) -&gt; @builtin(position) vec4f {
  return vec4f(position, 1.0);
}
</code></pre>
          </div>
          <p class="related"><strong class="label">Related</strong> <a href="#term-framegraph">Framegraph</a>, <a href="#term-gpubuffer">GpuBuffer</a></p>
          <p class="back-top"><a href="#top">Back to top</a></p>
        </article>

        <article class="term" id="term-gpudevicemanager">
          <h3>GPUDeviceManager</h3>
          <p><strong class="label">Definition</strong> Helper that requests the WebGPU adapter/device, negotiates features/limits, and centralizes lost-device handling and debug labels.</p>
          <div class="example">
            <strong class="label">Example</strong>
            <pre><code>import { GPUDeviceManager } from './gpu/GPUDeviceManager.js';

const gpu = new GPUDeviceManager();
await gpu.initialize();
const device = gpu.device;
</code></pre>
          </div>
          <p class="related"><strong class="label">Related</strong> <a href="#term-gpubuffer">GpuBuffer</a>, <a href="#term-gputexture">GpuTexture</a></p>
          <p class="back-top"><a href="#top">Back to top</a></p>
        </article>

        <article class="term" id="term-gpubuffer">
          <h3>GpuBuffer</h3>
          <p><strong class="label">Definition</strong> Wrapper for <code>GPUBuffer</code> creation and updates (vertex, index, uniform, storage) with consistent usage flags and upload helpers.</p>
          <div class="example">
            <strong class="label">Example</strong>
            <pre><code>import { GpuBuffer } from './gpu/GpuBuffer.js';

const verts = new Float32Array([
  0.0,  0.5, 0.0,
 -0.5, -0.5, 0.0,
  0.5, -0.5, 0.0,
]);

const vb = GpuBuffer.createVertex(device, verts, 'triangle-verts');
</code></pre>
          </div>
          <p class="related"><strong class="label">Related</strong> <a href="#term-gputexture">GpuTexture</a>, <a href="#term-framegraph">Framegraph</a></p>
          <p class="back-top"><a href="#top">Back to top</a></p>
        </article>

        <article class="term" id="term-gputexture">
          <h3>GpuTexture</h3>
          <p><strong class="label">Definition</strong> Helper for creating color/depth textures and render targets with resize semantics and default formats wired to engine policies.</p>
          <div class="example">
            <strong class="label">Example</strong>
            <pre><code>import { GpuTexture } from './gpu/GpuTexture.js';

const depthTex = GpuTexture.createDepthAttachment(device, {
  width: canvas.width,
  height: canvas.height,
  label: 'main-depth',
});
</code></pre>
          </div>
          <p class="related"><strong class="label">Related</strong> <a href="#term-framegraph">Framegraph</a>, <a href="#term-frame-loop">Frame loop</a></p>
          <p class="back-top"><a href="#top">Back to top</a></p>
        </article>

        <article class="term" id="term-gpusampler">
          <h3>GpuSampler</h3>
          <p><strong class="label">Definition</strong> Cache of common <code>GPUSampler</code> presets (point, linear, comparison) so materials reuse the same sampler objects per device.</p>
          <div class="example">
            <strong class="label">Example</strong>
            <pre><code>import { GpuSampler } from './gpu/GpuSampler.js';

const linearSampler = GpuSampler.getLinear(device);
// Use in a bind group with a sampled texture view
</code></pre>
          </div>
          <p class="related"><strong class="label">Related</strong> <a href="#term-gputexture">GpuTexture</a>, <a href="#term-framegraph">Framegraph</a></p>
          <p class="back-top"><a href="#top">Back to top</a></p>
        </article>

        <article class="term" id="term-framegraph">
          <h3>Framegraph</h3>
          <p><strong class="label">Definition</strong> Graph of render/compute/copy passes and virtual resources. Schedules passes automatically based on read/write dependencies.</p>
          <div class="example">
            <strong class="label">Example</strong>
            <pre><code>const fg = new FrameGraph();
const color = fg.createTexture({ name: 'mainColor' });

fg.addRenderPass('clear', pass =&gt; {
  pass.write(color, { loadOp: 'clear' });
});
</code></pre>
          </div>
          <p class="related"><strong class="label">Related</strong> <a href="#term-frame-loop">Frame loop</a>, <a href="#term-platform-canvas">Platform canvas binding</a></p>
          <p class="back-top"><a href="#top">Back to top</a></p>
        </article>

        <article class="term" id="term-frame-loop">
          <h3>Frame loop</h3>
          <p><strong class="label">Definition</strong> Main browser loop that calls <code>beginFrame() → buildGraph() → execute() → present()</code> every animation frame and wires timing into ECS/net.</p>
          <div class="example">
            <strong class="label">Example</strong>
            <pre><code>function frame(ts) {
  engine.beginFrame(ts);
  engine.buildFramegraph();
  engine.executeFramegraph();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</code></pre>
          </div>
          <p class="related"><strong class="label">Related</strong> <a href="#term-framegraph">Framegraph</a>, <a href="#term-event-bus">Event bus</a></p>
          <p class="back-top"><a href="#top">Back to top</a></p>
        </article>

        <article class="term" id="term-platform-canvas">
          <h3>Platform canvas binding</h3>
          <p><strong class="label">Definition</strong> Code in <code>engine/core/platform</code> that picks the target canvas, handles DPR/resizes, and creates the WebGPU context/swapchain.</p>
          <div class="example">
            <strong class="label">Example</strong>
            <pre><code>const canvas = document.querySelector('#game');
const context = canvas.getContext('webgpu');
context.configure({ device, format });
</code></pre>
          </div>
          <p class="related"><strong class="label">Related</strong> <a href="#term-webgpu">WebGPU</a>, <a href="#term-frame-loop">Frame loop</a></p>
          <p class="back-top"><a href="#top">Back to top</a></p>
        </article>

        <article class="term" id="term-event-bus">
          <h3>Event bus</h3>
          <p><strong class="label">Definition</strong> Central pub/sub layer in <code>engine/core/events</code> for engine, input, gameplay, and debug events. Avoids hidden singletons and DOM listeners.</p>
          <div class="example">
            <strong class="label">Example</strong>
            <pre><code>import { eventBus } from './events/EventBus.js';

eventBus.subscribe('input:move', (payload) =&gt; {
  console.log('Move', payload.direction);
});
</code></pre>
          </div>
          <p class="related"><strong class="label">Related</strong> <a href="#term-frame-loop">Frame loop</a></p>
          <p class="back-top"><a href="#top">Back to top</a></p>
        </article>
      </div>
    </main>
  </div>
</body>
</html>
